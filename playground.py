import numpy as np

if __name__ == '__main__':
       mat = np.array([[1, 2, 3, 4, 5],
                       [6, 7, 8, 9, 10],
                       [11, 12, 13, 14, 15],
                       [16, 17, 18, 19, 20],
                       [21, 22, 23, 24, 25]])

       x = np.array([0, 0, 1, 1, 1, 3, 3, 4])
       y = np.array([0, 1, 0, 3, 4, 1, 4, 0])

       print(mat[x, y])
       print(mat[x][y])

       """
       这里用的是 高级成对索引 (advanced indexing with two arrays)。
规则是：把 x[i], y[i] 成对使用，取出每一个坐标对应的元素。
	•	(0,0) → 1
	•	(0,1) → 2
	•	(1,0) → 6
	•	(1,3) → 9
	•	(1,4) → 10
	•	(3,1) → 17
	•	(3,4) → 20
	•	(4,0) → 21
	所以输出就是：[ 1  2  6  9 10 17 20 21]

    
    这是 两次索引，不是成对索引：
	1.	mat[x]：先从 mat 里取出 x 指定的行。
	•	x = [0,0,1,1,1,3,3,4]
	•	于是得到一个数组，形状是 (8,5)，每行都是 mat 的一行。
	•	前两行是 mat[0] = [1,2,3,4,5]，接下来三行是 mat[1]，再两行 mat[3]，最后一行 mat[4]。
得到：
[[ 1  2  3  4  5]
 [ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [ 6  7  8  9 10]
 [ 6  7  8  9 10]
 [16 17 18 19 20]
 [16 17 18 19 20]
 [21 22 23 24 25]]
 
 2.	[y]：再在这个结果上取行，y = [0,1,0,3,4,1,4,0]。
	•	比如索引 0 行 → [1,2,3,4,5]
	•	索引 1 行 → [1,2,3,4,5]
	•	索引 3 行 → [6,7,8,9,10]
	•	…以此类推。

结果就是一个 (8,5) 的二维数组：

[[ 1  2  3  4  5]
 [ 1  2  3  4  5]
 [ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [ 6  7  8  9 10]
 [ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [ 1  2  3  4  5]]
 
 📌 总结
	•	mat[x, y] → 成对索引，取出若干具体坐标上的单个元素 → 1D array。
	•	mat[x][y] → 先选行，再从这个子数组里选行 → 得到一堆整行 → 2D array。

       """